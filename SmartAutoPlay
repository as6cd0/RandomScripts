-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")

-- CONSTANTS & CONFIG
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local CHARACTER_SETUP_DELAY = 2

local AI_CONFIG = {
    REACTION_BASE = 0.18,      -- Base human reaction (seconds)
    REACTION_VAR = 0.05,       -- Variance (Gaussian)
    PANIC_MULTIPLIER = 0.6,    -- Faster reaction when panicking
    FAIL_RATE_BASE = 0.03,     -- 3% chance to fail parry (Human Error)
    JITTER_INTENSITY = 0.15,   -- Camera shake intensity
    PARRY_DISTANCE = 6,        -- Max distance to attempt parry
    PING_OFFSET = 0.04,        -- Estimation of server latency handling
}

-- SECTION 6: ARCHITECTURE & OPTIMIZATION (MAID CLASS)
local Maid = {}
Maid.__index = Maid

function Maid.new()
    local self = setmetatable({}, Maid)
    self._tasks = {}
    return self
end

function Maid:Give(task)
    if task == nil then return end
    table.insert(self._tasks, task)
    return task
end

function Maid:Clean()
    for _, task in pairs(self._tasks) do
        if typeof(task) == "RBXScriptConnection" then
            task:Disconnect()
        elseif type(task) == "function" then
            task()
        elseif task.Destroy then
            task:Destroy()
        end
    end
    self._tasks = {}
end

local maid = Maid.new()

-- UTILITY MATH (GAUSSIAN / NORMAL DISTRIBUTION)
local function RandomGaussian(mean, stddev)
    local y1
    local y2
    local x1
    local x2
    local w
    repeat
        x1 = 2 * math.random() - 1
        x2 = 2 * math.random() - 1
        w = x1 * x1 + x2 * x2
    until w >= 1 or w == 0
    w = math.sqrt((-2 * math.log(w)) / w)
    return mean + (x1 * w * stddev)
end

local function Lerp(a, b, t)
    return a + (b - a) * t
end

local function GetDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

-- SECTION 1: PERCEPTION & PHYSICS
local Physics = {
    Gravity = workspace.Gravity,
    BallCache = {},
    LastVelocities = {}
}

function Physics.PredictTrajectory(ball, timeAhead)
    if not ball or not ball.Parent then return nil end
    
    local vel = ball.AssemblyLinearVelocity
    local pos = ball.Position
    
    -- Curve Detection: Compare current acceleration vs history
    local lastVel = Physics.LastVelocities[ball]
    Physics.LastVelocities[ball] = vel
    
    local isCurving = false
    if lastVel then
        local diff = (vel - lastVel).Magnitude
        if diff > 15 then -- Arbitrary threshold for curveball detection
            isCurving = true
        end
    end
    
    -- Simple linear prediction with gravity offset
    local gravityOffset = Vector3.new(0, -0.5 * Physics.Gravity * (timeAhead^2), 0)
    return pos + (vel * timeAhead) + gravityOffset, isCurving
end

function Physics.CalculateTTI(ball, characterPos)
    if not ball then return math.huge end
    local dist = GetDistance(ball.Position, characterPos)
    local speed = ball.AssemblyLinearVelocity.Magnitude
    
    if speed == 0 then return math.huge end
    
    -- Add dynamic "Kill Zone" check (ball slows down slightly at end of curve)
    local killZoneRadius = 10 + (speed * 0.1)
    
    local timeToImpact = (dist - killZoneRadius) / speed
    return math.max(0, timeToImpact)
end

function Physics.IsVisible(targetPos)
    local character = LocalPlayer.Character
    if not character then return false end
    local head = character:FindFirstChild("Head")
    if not head then return false end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = workspace:Raycast(head.Position, targetPos - head.Position, rayParams)
    return result == nil or (result.Instance:IsDescendantOf(targetPos.Parent))
end

function Physics.IsTargetingMe(ball)
    if not ball then return false end
    local char = LocalPlayer.Character
    if not char then return false end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    
    local toMe = (root.Position - ball.Position).Unit
    local ballVel = ball.AssemblyLinearVelocity.Unit
    
    -- Dot product > 0.9 means roughly facing me
    return toMe:Dot(ballVel) > 0.85
end

function Physics.GetRealBalls()
    local balls = {}
    -- Common folder names in Blade Ball games
    local container = workspace:FindFirstChild("Balls") or workspace
    for _, obj in pairs(container:GetDescendants()) do
        if obj:IsA("BasePart") then
            local attr = obj:GetAttribute("realBall")
            -- Filter fake balls or visual glitches
            if attr == true or (obj.Name:lower():find("ball") and obj:GetMass() > 1) then
                table.insert(balls, obj)
            end
        end
    end
    return balls
end

-- SECTION 2: OPPONENT PROFILING (MEMORY)
local Memory = {
    Profiles = {},
    MyKiller = nil,
    DeathCount = 0
}

function Memory.UpdateProfile(player, eventType, data)
    if not Memory.Profiles[player] then
        Memory.Profiles[player] = {
            Aggression = 0.5, -- 0 to 1
            CurveTendency = 0,
            ThreatLevel = 1,
            IsAFK = false,
            LastPosition = Vector3.new(0,0,0),
            IsAllied = false,
            InsultedBot = false
        }
    end
    
    local profile = Memory.Profiles[player]
    
    if eventType == "AGGRESSIVE_MOVE" then
        profile.Aggression = math.min(1, profile.Aggression + 0.05)
    elseif eventType == "KILL" then
        profile.ThreatLevel = profile.ThreatLevel + 1
        if data == LocalPlayer.Name then
            Memory.MyKiller = player
            Memory.DeathCount = Memory.DeathCount + 1
        end
    elseif eventType == "CURVE_BALL" then
        profile.CurveTendency = profile.CurveTendency + 1
    elseif eventType == "CHAT_INSULT" then
        profile.InsultedBot = true
    elseif eventType == "AFK_CHECK" then
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local currentPos = player.Character.HumanoidRootPart.Position
            if (currentPos - profile.LastPosition).Magnitude < 1 then
                profile.IsAFK = true
            else
                profile.IsAFK = false
            end
            profile.LastPosition = currentPos
        end
    end
end

function Memory.GetHighestThreat()
    local highest = nil
    local highestScore = -1
    
    for player, profile in pairs(Memory.Profiles) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local score = (profile.ThreatLevel * 2) + (profile.Aggression * 5)
            if profile.InsultedBot then score = score + 100 end -- Priority Target
            if score > highestScore then
                highestScore = score
                highest = player
            end
        end
    end
    return highest
end

-- SECTION 3: HUMAN-LIKE MOTOR CONTROL
local Motor = {
    CurrentLookTarget = nil,
    LastClickTime = 0,
    PanicMode = false
}

function Motor.LookAt(targetPos, dt)
    if not targetPos then return end
    
    local head = LocalPlayer.Character:FindFirstChild("Head")
    if not head then return end
    
    -- Micro-Jitter
    local jitter = Vector3.new(
        RandomGaussian(0, AI_CONFIG.JITTER_INTENSITY),
        RandomGaussian(0, AI_CONFIG.JITTER_INTENSITY),
        RandomGaussian(0, AI_CONFIG.JITTER_INTENSITY)
    )
    
    local targetWithJitter = targetPos + jitter
    local goalCFrame = CFrame.lookAt(head.Position, targetWithJitter)
    
    -- Smooth Camera (Tweening logic manually implemented for per-frame control)
    local alpha = Motor.PanicMode and 0.4 or 0.1 -- Panic = faster movement
    head.CFrame = head.CFrame:Lerp(goalCFrame, alpha)
    
    -- Sync Camera
    Camera.CFrame = head.CFrame
end

function Motor.SimulateParry()
    if tick() - Motor.LastClickTime < 0.5 then return end -- Debounce
    
    -- Input Lag Simulation
    local lag = RandomGaussian(0.02, 0.01)
    
    -- Variable Press Duration
    local pressDuration = RandomGaussian(0.05, 0.01)
    
    -- Human Error Check
    local errorChance = AI_CONFIG.FAIL_RATE_BASE
    if Memory.MyKiller then errorChance = errorChance + 0.05 end
    
    if math.random() < errorChance then
        -- Fail to parry intentionally
        return
    end
    
    task.wait(lag)
    
    -- Virtual Input
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    task.wait(pressDuration)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
    
    Motor.LastClickTime = tick()
end

-- SECTION 4: TACTICAL MOVEMENT
local Movement = {
    Path = nil,
    TargetPos = nil,
    OrbitalAngle = 0
}

function Movement.MoveTo(pos)
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    humanoid:MoveTo(pos)
end

function Movement.OrbitalMovement(center, radius)
    Movement.OrbitalAngle = Movement.OrbitalAngle + 0.05
    local offset = Vector3.new(math.cos(Movement.OrbitalAngle), 0, math.sin(Movement.OrbitalAngle)) * radius
    Movement.MoveTo(center + offset)
end

function Movement.TacticalJump(ballPos)
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not root then return end
    
    local distToBall = GetDistance(root.Position, ballPos)
    
    -- Jump only if ball is close and fast
    if distToBall < 15 and not humanoid.Jump and not humanoid.FloorMaterial == Enum.Material.Air then
        if math.random() < 0.3 then -- Don't jump spam
            humanoid.Jump = true
        end
    end
end

function Movement.SafeNavigate(targetPos)
    -- Ground Safety Check
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = workspace:Raycast(targetPos + Vector3.new(0, 5, 0), Vector3.new(0, -20, 0), rayParams)
    if not result then return false end -- Void below
    
    -- Zig Zag Logic
    local zigZag = Vector3.new(math.sin(tick()*2)*2, 0, 0)
    
    -- Use Pathfinding if distance is large or complex
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if root and GetDistance(root.Position, targetPos) > 30 then
        task.spawn(function()
            local path = PathfindingService:CreatePath({AgentRadius = 2, AgentHeight = 5})
            local success, err = pcall(function()
                path:ComputeAsync(root.Position, targetPos)
            end)
            if success and path.Status == Enum.PathStatus.Success then
                local waypoints = path:GetWaypoints()
                if #waypoints > 1 then
                    Movement.MoveTo(waypoints[2].Position) -- Move to first real waypoint
                end
            else
                Movement.MoveTo(targetPos + zigZag)
            end
        end)
    else
        Movement.MoveTo(targetPos + zigZag)
    end
end

-- SECTION 5: SOCIAL ENGINEERING
local Social = {
    NextChatTime = 0,
    Emotes = {
        "rbxassetid://5106345846", -- Wave
        "rbxassetid://3344652363", -- Laugh
        "rbxassetid://4857019846"  -- Flex
    }
}

function Social.Say(msg)
    if tick() < Social.NextChatTime then return end
    
    -- Chat Spoofing (Standard method)
    local chatEvent = TextChatService and TextChatService:FindFirstChild("TextChannels") and TextChatService.TextChannels:FindFirstChild("RBXGeneral") or ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest")
    
    if chatEvent then
        if TextChatService then
            chatEvent:SendAsync(msg)
        else
            chatEvent:FireServer(msg, "All")
        end
    end
    
    Social.NextChatTime = tick() + math.random(5, 15)
end

function Social.ReactToEvent(eventType)
    local rng = math.random()
    if eventType == "KILL" then
        if rng < 0.3 then Social.Say("ez") end
        if rng < 0.2 then Social.PlayEmote() end
        if rng < 0.4 then Social.BMSpin() end
    elseif eventType == "DEATH" then
        if rng < 0.4 then Social.Say("lag") end
        if rng < 0.1 then Social.Say("wp") end
        if Memory.DeathCount >= 3 then Social.RageQuitSim() end
    elseif eventType == "WIN" then
        if rng < 0.5 then Social.Say("gg") end
    end
end

function Social.PlayEmote()
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid then
        local animId = Social.Emotes[math.random(1, #Social.Emotes)]
        local anim = Instance.new("Animation")
        anim.AnimationId = animId
        local track = humanoid:LoadAnimation(anim)
        track:Play()
        track.Ended:Connect(function() track:Destroy() anim:Destroy() end)
    end
end

function Social.BMSpin()
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if root then
        local startC = root.CFrame
        local spin = TweenService:Create(root, TweenInfo.new(1), {CFrame = startC * CFrame.Angles(0, math.rad(360), 0)})
        spin:Play()
    end
end

function Social.RageQuitSim()
    -- "Erratic" behavior: Spin camera wildly, spam crouch
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if root then
        for i = 1, 10 do
            root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(36), 0)
            task.wait(0.05)
        end
    end
    -- Then "calm down"
    task.wait(2)
    Memory.DeathCount = 0 -- Reset rage counter
end

-- MAIN AI BRAIN
local Brain = {
    State = "IDLE", -- IDLE, OBSERVE, ENGAGE, EVADE, PANIC, FAKE_AFK
    ActiveBall = nil,
    LastStateChange = 0
}

local function SetState(newState)
    if Brain.State == newState then return end
    Brain.State = newState
    Brain.LastStateChange = tick()
end

local function DetectModerators()
    -- Simple heuristic: Check for players with Admin badge or specific names
    for _, player in pairs(Players:GetPlayers()) do
        if player.Name:lower():find("admin") or player:GetRankInGroup(0) > 200 then -- Mock group check
            return true
        end
    end
    return false
end

local function MainLoop()
    if DetectModerators() then
        -- Disable AI features if admin detected
        return 
    end
    
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChild("Humanoid")
    
    if not root or not hum or hum.Health <= 0 then return end
    
    -- 1. Perception: Scan for balls
    local balls = Physics.GetRealBalls()
    local closestThreat = nil
    local minTTI = math.huge
    
    for _, ball in pairs(balls) do
        local tti = Physics.CalculateTTI(ball, root.Position)
        local isTargetingMe = Physics.IsTargetingMe(ball)
        local isVisible = Physics.IsVisible(ball.Position)
        
        -- Weigh threat
        if isTargetingMe and isVisible then
            if tti < minTTI then
                minTTI = tti
                closestThreat = ball
            end
        end
        
        -- Update Memory based on ball holder (simplified)
        local owner = ball:GetAttribute("owner") -- Mock attribute, usually exists in these games
        if owner then
            local ownerPlr = Players:FindFirstChild(owner)
            if ownerPlr then Memory.UpdateProfile(ownerPlr, "AGGRESSIVE_MOVE") end
        end
    end
    
    -- 2. State Machine Decision
    local nearbyPlayers = 0
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            if GetDistance(root.Position, p.Character.HumanoidRootPart.Position) < 20 then
                nearbyPlayers = nearbyPlayers + 1
            end
        end
    end
    
    -- State Transitions
    if Brain.State ~= "FAKE_AFK" then
        if closestThreat and minTTI < 0.8 then
            if nearbyPlayers > 3 and minTTI < 0.4 then
                SetState("PANIC")
            else
                SetState("EVADE")
            end
        elseif closestThreat and minTTI < 2.5 then
            SetState("ENGAGE")
        elseif math.random() < 0.001 then -- 0.1% chance per frame to fake AFK
            SetState("FAKE_AFK")
        else
            SetState("IDLE")
        end
    else
        -- Break Fake AFK if threat is immediate
        if closestThreat and minTTI < 0.6 then
            SetState("EVADE")
        end
    end
    
    -- 3. Execution based on State
    Motor.PanicMode = (Brain.State == "PANIC")
    
    if Brain.State == "FAKE_AFK" then
        -- Stand still
        hum:Move(Vector3.new(0,0,0), true)
        -- Randomly look around slightly
        Motor.LookAt(root.Position + Vector3.new(math.sin(tick()), 0, math.cos(tick())), 0.1)
        
    elseif Brain.State == "PANIC" then
        if closestThreat then
            Motor.LookAt(closestThreat.Position, 0.1)
            Motor.SimulateParry()
            Movement.OrbitalMovement(root.Position, 5) -- Spin in place
        end
        
    elseif Brain.State == "EVADE" or Brain.State == "ENGAGE" then
        if closestThreat then
            local predictedPos, isCurving = Physics.PredictTrajectory(closestThreat, 0.3 + (AI_CONFIG.PING_OFFSET))
            
            Motor.LookAt(predictedPos, 0.2)
            
            if isCurving then
                -- Side step
                local perp = Vector3.new(-closestThreat.AssemblyLinearVelocity.Z, 0, closestThreat.AssemblyLinearVelocity.X).Unit
                Movement.SafeNavigate(root.Position + (perp * 5))
            else
                -- Move to intercept
                if GetDistance(root.Position, predictedPos) > AI_CONFIG.PARRY_DISTANCE then
                    Movement.SafeNavigate(predictedPos)
                else
                    hum:Move(Vector3.new(0,0,0), true) -- Stop and prep
                end
            end
            
            -- Parry Timing Calculation
            local reactionTime = RandomGaussian(AI_CONFIG.REACTION_BASE, AI_CONFIG.REACTION_VAR)
            if Brain.State == "PANIC" then reactionTime = reactionTime * AI_CONFIG.PANIC_MULTIPLIER end
            
            -- Dynamic Adjustment: If I died to this player before, speed up
            -- (Mock logic: Assume ball owner is the threat)
            
            if minTTI <= reactionTime then
                Motor.SimulateParry()
            end
            
            Movement.TacticalJump(closestThreat.Position)
        end
        
    elseif Brain.State == "IDLE" then
        -- Look at nearest threat player
        local threat = Memory.GetHighestThreat()
        if threat and threat.Character and threat.Character:FindFirstChild("HumanoidRootPart") then
            Motor.LookAt(threat.Character.HumanoidRootPart.Position, 0.05)
        else
            -- Inspect surroundings
            local randomLook = root.Position + Vector3.new(math.cos(tick()), 0, math.sin(tick())) * 10
            Motor.LookAt(randomLook, 0.02)
        end
        
        -- Random Crouch/Slide
        if math.random() < 0.01 then
            VirtualInputManager:SendKeyEvent(true, "LeftControl", false, game)
            task.wait(0.2)
            VirtualInputManager:SendKeyEvent(false, "LeftControl", false, game)
        end
    end
end

-- INITIALIZATION
local function Initialize()
    -- Wait for character
    if not LocalPlayer.Character then LocalPlayer.CharacterAdded:Wait() end
    task.wait(CHARACTER_SETUP_DELAY)
    
    -- Connections
    maid:Give(RunService.Heartbeat:Connect(function(dt)
        -- Run Physics & Logic
        task.spawn(MainLoop) -- Non-blocking
        
        -- Monitor Memory (Separate Loop to save CPU)
        for player, _ in pairs(Memory.Profiles) do
            Memory.UpdateProfile(player, "AFK_CHECK")
        end
    end))
    
    maid:Give(LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(1)
        -- Reset specific states on respawn
        Brain.State = "IDLE"
        Movement.Path = nil
    end))
    
    -- Chat Listener for Social Engineering
    if TextChatService then
        maid:Give(TextChatService.ChatInputBarFocused:GetSignal():Connect(function()
            -- Stop fighting while typing
            Brain.State = "IDLE"
        end))
    end
    
    print("NEURAL-HUMAN AI INITIALIZED")
end

Initialize()

-- SELF DESTRUCT WRAPPER
_G.KillAI = function()
    maid:Clean()
    print("AI TERMINATED")
end
